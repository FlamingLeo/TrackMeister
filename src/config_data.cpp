// This file has been generated by generate_config_data.py.
// DO NOT EDIT! Changes will be overwritten without asking.

#include <cstdint>

#include "config.h"
#include "config_item.h"

static const EnumItem e_FilterMethod[] = {
    { "None",   static_cast<int>(FilterMethod::None)   },
    { "Linear", static_cast<int>(FilterMethod::Linear) },
    { "Cubic",  static_cast<int>(FilterMethod::Cubic)  },
    { "Sinc",   static_cast<int>(FilterMethod::Sinc)   },
    { "Amiga",  static_cast<int>(FilterMethod::Amiga)  },
    { "A500",   static_cast<int>(FilterMethod::A500)   },
    { "A1200",  static_cast<int>(FilterMethod::A1200)  },
    { "Auto",   static_cast<int>(FilterMethod::Auto)   },
    { nullptr, 0 }
};

const ConfigItem g_ConfigItems[] = { {
        true, "fullscreen                 ",
        "whether to run in fullscreen mode",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.fullscreen); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.fullscreen, s), s); }
    }, {
        false, "window width               ",
        "initial window width  in non-fullscreen mode, in pixels",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.windowWidth); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.windowWidth, s), s); }
    }, {
        false, "window height              ",
        "initial window height in non-fullscreen mode, in pixels",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.windowHeight); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.windowHeight, s), s); }
    }, {
        true, "sample rate                ",
        "audio sampling rate",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.sampleRate); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.sampleRate, s), s); }
    }, {
        false, "audio buffer size          ",
        "size of the audio buffer, in samples; if there are dropouts, try doubling this value",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.audioBufferSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.audioBufferSize, s), s); }
    }, {
        false, "filter                     ",
        "audio resampling filter to be used [possible values: 'None', 'Linear', 'Cubic', 'Sinc', 'Amiga', 'A500', 'A1200', 'Auto']",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatEnum(static_cast<int>(cfg.filter), e_FilterMethod); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { int value; if (ctx.checkParseResult(ConfigItem::parseEnum(value, s, e_FilterMethod), s)) { cfg.filter = static_cast<FilterMethod>(value); } }
    }, {
        false, "stereo separation          ",
        "amount of stereo separation, in percent (0 = mono, 100 = full stereo, higher = fake surround)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.stereoSeparation); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.stereoSeparation, s), s); }
    }, {
        false, "gain                       ",
        "global gain to apply, in decibels",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.gain); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.gain, s), s); }
    }, {
        true, "auto play                  ",
        "automatically start playing when loading a module; you may want to turn this off for actual competitions",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.autoPlay); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.autoPlay, s), s); }
    }, {
        false, "loop                       ",
        "whether to loop the song after it's finished, or play the song's programmed loop if it there is one",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.loop); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.loop, s), s); }
    }, {
        false, "fade out after loop        ",
        "whether to trigger a slow fade-out after the song looped",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.fadeOutAfterLoop); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.fadeOutAfterLoop, s), s); }
    }, {
        false, "fade out at                ",
        "number of seconds after which the song shall be slowly faded out automatically (0 = no auto-fade)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.fadeOutAt); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.fadeOutAt, s), s); }
    }, {
        false, "fade duration              ",
        "duration of a fade-out, in seconds",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.fadeDuration); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.fadeDuration, s), s); }
    }, {
        true, "track number enabled       ",
        "whether to extract and display the track number from the filename; used if the filename starts with two digits followed by a dash (-), underscore (_) or space",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.trackNumberEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.trackNumberEnabled, s), s); }
    }, {
        false, "auto scroll enabled        ",
        "whether to enable automatic scrolling in the metadata sidebar after loading a module",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.autoScrollEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.autoScrollEnabled, s), s); }
    }, {
        false, "max scroll duration        ",
        "maximum duration after which automatic metadata scrolling reaches the end, in seconds; if the module is shorter than that, the module's duration will be used instead",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.maxScrollDuration); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.maxScrollDuration, s), s); }
    }, {
        true, "empty background           ",
        "background color of \"no module loaded\" screen",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.emptyBackground); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.emptyBackground, s), s); }
    }, {
        false, "pattern background         ",
        "background color of pattern display",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternBackground); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternBackground, s), s); }
    }, {
        false, "info background            ",
        "background color of the top information bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoBackground); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoBackground, s), s); }
    }, {
        false, "meta background            ",
        "background color of the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.metaBackground); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.metaBackground, s), s); }
    }, {
        false, "shadow color               ",
        "color of the info and metadata bar's shadows",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.shadowColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.shadowColor, s), s); }
    }, {
        true, "empty text size            ",
        "size of the \"no module loaded\" text",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.emptyTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.emptyTextSize, s), s); }
    }, {
        false, "empty text color           ",
        "color of the \"no module loaded\" text",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.emptyTextColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.emptyTextColor, s), s); }
    }, {
        true, "info enabled               ",
        "whether to enable the top information bar by default after loading a module",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.infoEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.infoEnabled, s), s); }
    }, {
        false, "info margin X              ",
        "outer left margin inside the info bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoMarginX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoMarginX, s), s); }
    }, {
        false, "info margin Y              ",
        "upper and lower margin inside the info bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoMarginY); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoMarginY, s), s); }
    }, {
        false, "info track text size       ",
        "text size of the track number",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoTrackTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoTrackTextSize, s), s); }
    }, {
        false, "info text size             ",
        "text size of the filename, title and artist lines",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoTextSize, s), s); }
    }, {
        false, "info details text size     ",
        "text size of the technical details line",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoDetailsTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoDetailsTextSize, s), s); }
    }, {
        false, "info line spacing          ",
        "extra space between the info bar's lines",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoLineSpacing); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoLineSpacing, s), s); }
    }, {
        false, "info track padding X       ",
        "horitontal space between the track number and the other information in the info bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoTrackPaddingX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoTrackPaddingX, s), s); }
    }, {
        false, "info key padding X         ",
        "horizontal space between the \"File\", \"Artist\" and \"Title\" heading and the content text",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoKeyPaddingX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoKeyPaddingX, s), s); }
    }, {
        false, "info track color           ",
        "color of the track number",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoTrackColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoTrackColor, s), s); }
    }, {
        false, "info key color             ",
        "color of the \"File\", \"Artist\" and \"Title\" headings",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoKeyColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoKeyColor, s), s); }
    }, {
        false, "info colon color           ",
        "color of the colon following the headings",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoColonColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoColonColor, s), s); }
    }, {
        false, "info value color           ",
        "color of the file, artist and title texts",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoValueColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoValueColor, s), s); }
    }, {
        false, "info details color         ",
        "color of the technical details line",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.infoDetailsColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.infoDetailsColor, s), s); }
    }, {
        false, "info shadow size           ",
        "width of the shadow below the info bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.infoShadowSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.infoShadowSize, s), s); }
    }, {
        true, "meta enabled               ",
        "whether to enable the metadata sidebar by default after loading a module",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.metaEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.metaEnabled, s), s); }
    }, {
        false, "meta show message          ",
        "whether the metadata sidebar shall include the module message section",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.metaShowMessage); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.metaShowMessage, s), s); }
    }, {
        false, "meta show instrument names ",
        "whether the metadata sidebar shall include the instrument names section",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.metaShowInstrumentNames); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.metaShowInstrumentNames, s), s); }
    }, {
        false, "meta show sample names     ",
        "whether the metadata sidebar shall include the sample names section",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.metaShowSampleNames); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.metaShowSampleNames, s), s); }
    }, {
        false, "meta margin X              ",
        "left and right margin inside the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaMarginX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaMarginX, s), s); }
    }, {
        false, "meta margin Y              ",
        "upper and lower margin inside the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaMarginY); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaMarginY, s), s); }
    }, {
        false, "meta text size             ",
        "text size in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaTextSize, s), s); }
    }, {
        false, "meta message width         ",
        "approximate number of characters per line to allocate for the module message",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaMessageWidth); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaMessageWidth, s), s); }
    }, {
        false, "meta section margin        ",
        "vertical gap between sections in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaSectionMargin); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaSectionMargin, s), s); }
    }, {
        false, "meta heading color         ",
        "color of a section heading in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.metaHeadingColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.metaHeadingColor, s), s); }
    }, {
        false, "meta text color            ",
        "color of normal text in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.metaTextColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.metaTextColor, s), s); }
    }, {
        false, "meta index color           ",
        "color of the instrument/sample numbers in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.metaIndexColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.metaIndexColor, s), s); }
    }, {
        false, "meta colon color           ",
        "color of the colon between instrument/sample number and name in the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.metaColonColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.metaColonColor, s), s); }
    }, {
        false, "meta shadow size           ",
        "width of the shadow left to the the metadata sidebar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.metaShadowSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.metaShadowSize, s), s); }
    }, {
        true, "pattern text size          ",
        "desired size of the pattern display text",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternTextSize, s), s); }
    }, {
        false, "pattern min text size      ",
        "minimum allowed size of the pattern display text (if the pattern still doesn't fit with this, some channels won't be visible)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternMinTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternMinTextSize, s), s); }
    }, {
        false, "pattern line spacing       ",
        "extra vertical gap between rows in the pattern display",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternLineSpacing); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternLineSpacing, s), s); }
    }, {
        false, "pattern margin X           ",
        "left and right margin inside the pattern display",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternMarginX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternMarginX, s), s); }
    }, {
        false, "pattern bar padding X      ",
        "extra left and right padding of the current row bar in the pattern display",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternBarPaddingX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternBarPaddingX, s), s); }
    }, {
        false, "pattern bar border percent ",
        "border radius of the current row bar, in percent of the text size",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.patternBarBorderPercent); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.patternBarBorderPercent, s), s); }
    }, {
        false, "pattern bar background     ",
        "fill color of the current row bar",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternBarBackground); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternBarBackground, s), s); }
    }, {
        false, "pattern text color         ",
        "color of normal text in the pattern display (not used, as everything in the pattern display is covered by the following highlighting colors)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternTextColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternTextColor, s), s); }
    }, {
        false, "pattern dot color          ",
        "text color of the dots indicating unset notes/instruments/effects etc.",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternDotColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternDotColor, s), s); }
    }, {
        false, "pattern note color         ",
        "text color of normal notes (e.g. \"G#4\")",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternNoteColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternNoteColor, s), s); }
    }, {
        false, "pattern special color      ",
        "text color of special notes (e.g. \"===\")",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternSpecialColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternSpecialColor, s), s); }
    }, {
        false, "pattern instrument color   ",
        "text color of the instrument/sample index column",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternInstrumentColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternInstrumentColor, s), s); }
    }, {
        false, "pattern vol effect color   ",
        "text color of the volume effect column (e.g. the 'v' before the volume)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternVolEffectColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternVolEffectColor, s), s); }
    }, {
        false, "pattern vol param color    ",
        "text color of the volume effect parameter column",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternVolParamColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternVolParamColor, s), s); }
    }, {
        false, "pattern effect color       ",
        "text color of the effect type column",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternEffectColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternEffectColor, s), s); }
    }, {
        false, "pattern effect param color ",
        "text color of the effect parameter column",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternEffectParamColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternEffectParamColor, s), s); }
    }, {
        false, "pattern pos order color    ",
        "text color of the order number",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternPosOrderColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternPosOrderColor, s), s); }
    }, {
        false, "pattern pos pattern color  ",
        "text color of the pattern number",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternPosPatternColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternPosPatternColor, s), s); }
    }, {
        false, "pattern pos row color      ",
        "text color of the row number",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternPosRowColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternPosRowColor, s), s); }
    }, {
        false, "pattern pos dot color      ",
        "text color of the colon or dot between the order/pattern/row numbers",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternPosDotColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternPosDotColor, s), s); }
    }, {
        false, "pattern sep color          ",
        "text color of the bar ('|') between channels",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.patternSepColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.patternSepColor, s), s); }
    }, {
        false, "pattern alpha falloff      ",
        "amount of alpha falloff for the outermost rows in the pattern display; 0.0 = no falloff, 1.0 = falloff to full transparency",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.patternAlphaFalloff); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.patternAlphaFalloff, s), s); }
    }, {
        false, "pattern alpha falloff shape",
        "shape (power) of the alpha falloff in the pattern display; the higher, the more rows will retain a relatively high opacity",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.patternAlphaFalloffShape); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.patternAlphaFalloffShape, s), s); }
    }, {
        true, "channel names enabled      ",
        "whether to enable the channel name displays by default after loading a module",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.channelNamesEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.channelNamesEnabled, s), s); }
    }, {
        false, "channel name padding Y     ",
        "extra vertical padding in the channel name boxes",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.channelNamePaddingY); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.channelNamePaddingY, s), s); }
    }, {
        false, "channel name upper color   ",
        "color of the upper end of the channel name boxes",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.channelNameUpperColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.channelNameUpperColor, s), s); }
    }, {
        false, "channel name lower color   ",
        "color of the lower end of the channel name boxes",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.channelNameLowerColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.channelNameLowerColor, s), s); }
    }, {
        false, "channel name text color    ",
        "channel name text color",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.channelNameTextColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.channelNameTextColor, s), s); }
    }, {
        true, "vu enabled                 ",
        "whether to enable the fake VU meters by default after loading a module",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatBool(cfg.vuEnabled); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseBool(cfg.vuEnabled, s), s); }
    }, {
        false, "vu height                  ",
        "height of the fake VU meters",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.vuHeight); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.vuHeight, s), s); }
    }, {
        false, "vu upper color             ",
        "color of the upper end of the fake VU meters",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.vuUpperColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.vuUpperColor, s), s); }
    }, {
        false, "vu lower color             ",
        "color of the lower end of the fake VU meters",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.vuLowerColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.vuLowerColor, s), s); }
    }, {
        true, "toast text size            ",
        "text size of a \"toast\" status message",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.toastTextSize); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.toastTextSize, s), s); }
    }, {
        false, "toast margin X             ",
        "left and right margin inside a \"toast\" status message (not including the rounded borders)",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.toastMarginX); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.toastMarginX, s), s); }
    }, {
        false, "toast margin Y             ",
        "top and bottom margin inside a \"toast\" status message",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.toastMarginY); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.toastMarginY, s), s); }
    }, {
        false, "toast position Y           ",
        "vertical position of a \"toast\" status message, relative to the top of the display",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatInt(cfg.toastPositionY); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseInt(cfg.toastPositionY, s), s); }
    }, {
        false, "toast background color     ",
        "background color of a \"toast\" status message",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.toastBackgroundColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.toastBackgroundColor, s), s); }
    }, {
        false, "toast text color           ",
        "text color of a \"toast\" status message",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatColor(cfg.toastTextColor); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseColor(cfg.toastTextColor, s), s); }
    }, {
        false, "toast duration             ",
        "time a \"toast\" status message shall be visible until it's completely faded out",
        [] (const Config& cfg) -> std::string { return ConfigItem::formatFloat(cfg.toastDuration); },
        [] (ConfigParserContext& ctx, Config& cfg, const char* s) { ctx.checkParseResult(ConfigItem::parseFloat(cfg.toastDuration, s), s); }
    },
    { false, nullptr, nullptr, nullptr, nullptr }
};

const char* g_DefaultConfigFileIntro =
    "; Edit and save this file as \"tmcp.ini\" in the program directory\n"
    "; to customize TMCP appearance and behavior.\n"
    "\n"
    "[TMCP]\n"
    "; TMCP default configuration.\n"
    "; \n"
    "; Unless explicitly noted otherwise, the unit for all lengths (text sizes,\n"
    "; margins etc.) is 1/1000th of the screen or window height, i.e. roughly\n"
    "; in the ballpark of (but *not* identical to!) pixels on a 1080p display.\n"
    "; All sizes will be rounded to full display pixels internally.\n"
    "; \n"
    "; In the INI file, colors are specified in hexadecimal RGB HTML/CSS notation,\n"
    "; e.g. #123abc or #f00 (which is equivalent to #ff0000). An optional fourth\n"
    "; component specifies alpha, with 00 = fully transparent and ff = fully\n"
    "; opaque. For example, #ff000080 is half-transparent red. (This is consistent\n"
    "; with the notation used e.g. by Inkscape.) If alpha is not specified, the\n"
    "; color is assumed to be fully opaque.\n";
