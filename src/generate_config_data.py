#!/usr/bin/env python3
import io
import re
import sys

def camelCase_to_space_case(x):
    words = ''.join(((' ' + c.lower()) if c.isupper() else c) for c in x).split()
    return ' '.join((word.upper() if (len(word) < 2) else word) for word in words)

if __name__ == "__main__":
    try:
        _, infile, outfile = sys.argv
    except ValueError:
        print("Usage:", sys.argv[0], "<config.h> <config_data.cpp>", file=sys.stderr)
        sys.exit(2)

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    enums = {}
    fields = []
    intro = [
        '; Edit and save this file as "tm.ini" in the program directory',
        '; to customize TrackMeister appearance and behavior.',
        '',
        '[TrackMeister]'
    ]
    name_maxlen = 0

    with open(infile, 'r') as f:
        in_enum, in_config = None, False
        lineno = 0
        comment = []
        for line in f:
            lineno += 1
            line = line.strip()

            # empty line -> clear comment block
            if not line:
                comment = []

            # comment
            m = re.match(r'//!\s?(.*)', line)
            if m:
                c = m.group(1)
                if not c.lower().startswith("in code,"):
                    comment.append('; ' + c)
                continue

            # start of enum
            m = re.match(r'enum class (\w+) {', line)
            if m:
                in_enum = m.group(1)
                enums[in_enum] = []
                continue

            # enum item
            m = in_enum and re.match(r'(\w+)(\s*=\s*\d+)?,?', line)
            if m:
                enums[in_enum].append(m.group(1))
                continue

            # start of config structure
            if line.startswith('struct Config {'):
                in_config = True
                new_section = True
                intro += comment
                continue

            # empty line inside config structure
            if in_config and not(line):
                new_section = True
                continue

            # config item
            m = in_config and re.match(r'''
                (?P<type>   \w+) \s*
                (?P<field>  \w+) \s*
                =                \s*
                (?P<default> .*?) ;
                \s* //!< \s*
                (?P<comment> .*)
            ''', line, flags=re.X)
            if m:
                type = m.group('type')
                field = m.group('field')
                name = camelCase_to_space_case(field)
                name_maxlen = max(name_maxlen, len(name))
                if not(type in {'bool', 'int', 'float', 'uint32_t'}) and not(type in enums):
                    print(f"{infile}:{lineno}: invalid type '{type}'", file=sys.stderr)
                else:
                    fields.append((new_section, type, field, name, m.group('comment').strip()))
                new_section = False

            # end of struct or enum
            if line.startswith('};'):
                in_enum, in_config = None, False
                continue

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    with io.StringIO() as f:
        f.write('// This file has been generated by generate_config_data.py.\n')
        f.write('// DO NOT EDIT! Changes will be overwritten without asking.\n\n')
        f.write('#include <cstdint>\n\n')
        f.write('#include "config.h"\n#include "config_item.h"\n')

        # write string<->enum mapping tables
        for enum, items in sorted(enums.items()):
            f.write(f'\nextern "C" const EnumItem e_{enum}[] = {{\n')
            item_maxlen = max(map(len, items))
            for item in items:
                f.write('    { "' + (item + '",').ljust(item_maxlen + 2) + f' static_cast<int>({enum}::' + (item + ')').ljust(item_maxlen + 1) + ' },\n')
            f.write('    { nullptr, 0 }\n};\n')

        # write main config item table
        f.write('\nconst ConfigItem g_ConfigItems[] = { {\n')
        first = True
        for new_section, type, field, name, desc in fields:
            if first: first = False
            else: f.write('    }, {\n')

            # add possible values to description
            if type in enums:
                desc += " [possible values: " + ", ".join(f"'{e}'" for e in enums[type]) + "]"

            # write name and description
            f.write(f'        {repr(new_section).lower()}, "{name.ljust(name_maxlen)}",\n')
            desc = desc.replace('"', '\\"')
            f.write(f'        "{desc}",\n')

            # write getters and setters
            if type in enums:
                f.write(f'        [] (const Config& cfg) -> std::string {{ return ConfigItem::formatEnum(static_cast<int>(cfg.{field}), e_{type}); }},\n')
                f.write(f'        [] (ConfigParserContext& ctx, Config& cfg, const char* s) {{ int value; if (ctx.checkParseResult(ConfigItem::parseEnum(value, s, e_{type}), s)) {{ cfg.{field} = static_cast<{type}>(value); }} }}\n')
            else:
                type = { "uint32_t": "Color" }.get(type, type.title())
                f.write(f'        [] (const Config& cfg) -> std::string {{ return ConfigItem::format{type}(cfg.{field}); }},\n')
                f.write(f'        [] (ConfigParserContext& ctx, Config& cfg, const char* s) {{ ctx.checkParseResult(ConfigItem::parse{type}(cfg.{field}, s), s); }}\n')

        f.write('    },\n    { false, nullptr, nullptr, nullptr, nullptr }\n};\n')

        f.write('\nconst char* g_DefaultConfigFileIntro =\n')
        first = True
        for line in intro:
            f.write((not(first) and '"\n' or '') + '    "' + line.replace('"', '\\"') + '\\n')
            first = False
        f.write('";\n')

        data = f.getvalue()

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

    with open(outfile, 'wb') as f:
        f.write(data.encode('utf-8').replace(b'\r', b''))
